variables:
  - name: 'errors'
    value: null
# Pipeline will be triggered for PR & any updates on the PR on all branches
pr:
  autoCancel: true
  branches:
    include:
    - '*'
  drafts: true

# Not triggering for CI since it is triggered for PRs
trigger: none

# Define 5 parallel jobs that run build script for specified targets
jobs:
- job: 'Validate_Pull_Request'
  strategy:
    maxParallel: 2
    matrix:
      IOS_FRAMEWORK: 
        target: "iosFramework iosTestApp sampleIosApp sampleIosAppSwift"
#      IOS_TEST_APP: 
#        target: "iosTestApp"
#      SAMPLE_IOS_APP: 
#        target: "sampleIosApp"
#      SAMPLE_IOS_APP_SWIFT: 
#        target: "sampleIosAppSwift"
      MAC_FRAMEWORK: 
        target: "macFramework"
  displayName: Validate Pull Request
  pool:
    vmImage: 'macOS-latest'
    timeOutInMinutes: 30

  steps:
  - task: CmdLine@2
    displayName: Installing dependencies
    inputs:
      script: |
        gem install xcpretty slather -N
      failOnStderr: true
  - checkout: self
    clean: true
    submodules: true
    fetchDepth: 1
    persistCredentials: false
  - task: Bash@3
    displayName: Removing any lingering codecov files. These can cause issues when the xcode version changes
    inputs:
      targetType: 'inline'
      script: |
        find . -name "*.gcda" -print0 | xargs -0 rm
  - task: Bash@3
    displayName: Run Build script & check for Errors
    inputs:
      targetType: 'inline'
      script: |
        { output=$(./build.py --target $(target) 2>&1 1>&3-) ;} 3>&1
        final_status=$(<status.txt)
        echo "FINAL STATUS  = ${final_status}"
        echo "POSSIBLE ERRORS: ${output}"
        
        if [ $final_status != "0" ]; then
          echo "Build & Testing Failed! \n ${output}" >&2
          output=$(echo "$output" | sed ':a;N;$!ba;s/\n/%0D%0A/g')
          echo "##vso[task.setvariable variable=errors]${output}"
        fi
      failOnStderr: true
  - task: Bash@3
    condition: always()
    displayName: Display Build & Test Errors
    inputs:
      targetType: 'inline'
      script: |
        rm -rf status.txt
        echo $(errors)
  
  